// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: terminals.sql

package models

import (
	"context"
	"database/sql"
	"time"
)

const createTerminal = `-- name: CreateTerminal :exec
INSERT INTO terminals (
    id, account_id, metadata, metadata_version,
    daemon_state, daemon_state_version, data_encryption_key
) VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateTerminalParams struct {
	ID                 string         `json:"id"`
	AccountID          string         `json:"account_id"`
	Metadata           string         `json:"metadata"`
	MetadataVersion    int64          `json:"metadata_version"`
	DaemonState        sql.NullString `json:"daemon_state"`
	DaemonStateVersion int64          `json:"daemon_state_version"`
	DataEncryptionKey  []byte         `json:"data_encryption_key"`
}

func (q *Queries) CreateTerminal(ctx context.Context, arg CreateTerminalParams) error {
	_, err := q.db.ExecContext(ctx, createTerminal,
		arg.ID,
		arg.AccountID,
		arg.Metadata,
		arg.MetadataVersion,
		arg.DaemonState,
		arg.DaemonStateVersion,
		arg.DataEncryptionKey,
	)
	return err
}

const deleteTerminal = `-- name: DeleteTerminal :exec
DELETE FROM terminals WHERE account_id = ? AND id = ?
`

type DeleteTerminalParams struct {
	AccountID string `json:"account_id"`
	ID        string `json:"id"`
}

func (q *Queries) DeleteTerminal(ctx context.Context, arg DeleteTerminalParams) error {
	_, err := q.db.ExecContext(ctx, deleteTerminal, arg.AccountID, arg.ID)
	return err
}

const getTerminal = `-- name: GetTerminal :one
SELECT id, account_id, metadata, metadata_version, daemon_state, daemon_state_version, data_encryption_key, seq, active, last_active_at, created_at, updated_at FROM terminals
WHERE account_id = ? AND id = ?
LIMIT 1
`

type GetTerminalParams struct {
	AccountID string `json:"account_id"`
	ID        string `json:"id"`
}

func (q *Queries) GetTerminal(ctx context.Context, arg GetTerminalParams) (Terminal, error) {
	row := q.db.QueryRowContext(ctx, getTerminal, arg.AccountID, arg.ID)
	var i Terminal
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Metadata,
		&i.MetadataVersion,
		&i.DaemonState,
		&i.DaemonStateVersion,
		&i.DataEncryptionKey,
		&i.Seq,
		&i.Active,
		&i.LastActiveAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listTerminals = `-- name: ListTerminals :many
SELECT id, account_id, metadata, metadata_version, daemon_state, daemon_state_version, data_encryption_key, seq, active, last_active_at, created_at, updated_at FROM terminals
WHERE account_id = ?
ORDER BY last_active_at DESC
`

func (q *Queries) ListTerminals(ctx context.Context, accountID string) ([]Terminal, error) {
	rows, err := q.db.QueryContext(ctx, listTerminals, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Terminal{}
	for rows.Next() {
		var i Terminal
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Metadata,
			&i.MetadataVersion,
			&i.DaemonState,
			&i.DaemonStateVersion,
			&i.DataEncryptionKey,
			&i.Seq,
			&i.Active,
			&i.LastActiveAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTerminalActivity = `-- name: UpdateTerminalActivity :exec
UPDATE terminals
SET active = ?, last_active_at = ?
WHERE account_id = ? AND id = ?
`

type UpdateTerminalActivityParams struct {
	Active       int64     `json:"active"`
	LastActiveAt time.Time `json:"last_active_at"`
	AccountID    string    `json:"account_id"`
	ID           string    `json:"id"`
}

func (q *Queries) UpdateTerminalActivity(ctx context.Context, arg UpdateTerminalActivityParams) error {
	_, err := q.db.ExecContext(ctx, updateTerminalActivity,
		arg.Active,
		arg.LastActiveAt,
		arg.AccountID,
		arg.ID,
	)
	return err
}

const updateTerminalDaemonState = `-- name: UpdateTerminalDaemonState :execrows
UPDATE terminals
SET daemon_state = ?, daemon_state_version = ?
WHERE account_id = ? AND id = ? AND daemon_state_version = ?
`

type UpdateTerminalDaemonStateParams struct {
	DaemonState          sql.NullString `json:"daemon_state"`
	DaemonStateVersion   int64          `json:"daemon_state_version"`
	AccountID            string         `json:"account_id"`
	ID                   string         `json:"id"`
	DaemonStateVersion_2 int64          `json:"daemon_state_version_2"`
}

func (q *Queries) UpdateTerminalDaemonState(ctx context.Context, arg UpdateTerminalDaemonStateParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateTerminalDaemonState,
		arg.DaemonState,
		arg.DaemonStateVersion,
		arg.AccountID,
		arg.ID,
		arg.DaemonStateVersion_2,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateTerminalMetadata = `-- name: UpdateTerminalMetadata :execrows
UPDATE terminals
SET metadata = ?, metadata_version = ?
WHERE account_id = ? AND id = ? AND metadata_version = ?
`

type UpdateTerminalMetadataParams struct {
	Metadata          string `json:"metadata"`
	MetadataVersion   int64  `json:"metadata_version"`
	AccountID         string `json:"account_id"`
	ID                string `json:"id"`
	MetadataVersion_2 int64  `json:"metadata_version_2"`
}

func (q *Queries) UpdateTerminalMetadata(ctx context.Context, arg UpdateTerminalMetadataParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateTerminalMetadata,
		arg.Metadata,
		arg.MetadataVersion,
		arg.AccountID,
		arg.ID,
		arg.MetadataVersion_2,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateTerminalSeq = `-- name: UpdateTerminalSeq :one
UPDATE terminals
SET seq = seq + 1
WHERE account_id = ? AND id = ?
RETURNING seq
`

type UpdateTerminalSeqParams struct {
	AccountID string `json:"account_id"`
	ID        string `json:"id"`
}

func (q *Queries) UpdateTerminalSeq(ctx context.Context, arg UpdateTerminalSeqParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateTerminalSeq, arg.AccountID, arg.ID)
	var seq int64
	err := row.Scan(&seq)
	return seq, err
}

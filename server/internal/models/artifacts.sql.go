// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: artifacts.sql

package models

import (
	"context"
	"time"
)

const createArtifact = `-- name: CreateArtifact :exec
INSERT INTO artifacts (
    id, account_id, header, header_version, body, body_version, data_encryption_key, seq
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateArtifactParams struct {
	ID                string `json:"id"`
	AccountID         string `json:"account_id"`
	Header            []byte `json:"header"`
	HeaderVersion     int64  `json:"header_version"`
	Body              []byte `json:"body"`
	BodyVersion       int64  `json:"body_version"`
	DataEncryptionKey []byte `json:"data_encryption_key"`
	Seq               int64  `json:"seq"`
}

func (q *Queries) CreateArtifact(ctx context.Context, arg CreateArtifactParams) error {
	_, err := q.db.ExecContext(ctx, createArtifact,
		arg.ID,
		arg.AccountID,
		arg.Header,
		arg.HeaderVersion,
		arg.Body,
		arg.BodyVersion,
		arg.DataEncryptionKey,
		arg.Seq,
	)
	return err
}

const deleteArtifact = `-- name: DeleteArtifact :exec
DELETE FROM artifacts
WHERE id = ? AND account_id = ?
`

type DeleteArtifactParams struct {
	ID        string `json:"id"`
	AccountID string `json:"account_id"`
}

func (q *Queries) DeleteArtifact(ctx context.Context, arg DeleteArtifactParams) error {
	_, err := q.db.ExecContext(ctx, deleteArtifact, arg.ID, arg.AccountID)
	return err
}

const getArtifactByID = `-- name: GetArtifactByID :one
SELECT id, account_id, header, header_version, body, body_version, data_encryption_key, seq, created_at, updated_at
FROM artifacts
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetArtifactByID(ctx context.Context, id string) (Artifact, error) {
	row := q.db.QueryRowContext(ctx, getArtifactByID, id)
	var i Artifact
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Header,
		&i.HeaderVersion,
		&i.Body,
		&i.BodyVersion,
		&i.DataEncryptionKey,
		&i.Seq,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getArtifactByIDAndAccount = `-- name: GetArtifactByIDAndAccount :one
SELECT id, account_id, header, header_version, body, body_version, data_encryption_key, seq, created_at, updated_at
FROM artifacts
WHERE id = ? AND account_id = ?
LIMIT 1
`

type GetArtifactByIDAndAccountParams struct {
	ID        string `json:"id"`
	AccountID string `json:"account_id"`
}

func (q *Queries) GetArtifactByIDAndAccount(ctx context.Context, arg GetArtifactByIDAndAccountParams) (Artifact, error) {
	row := q.db.QueryRowContext(ctx, getArtifactByIDAndAccount, arg.ID, arg.AccountID)
	var i Artifact
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Header,
		&i.HeaderVersion,
		&i.Body,
		&i.BodyVersion,
		&i.DataEncryptionKey,
		&i.Seq,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listArtifactsByAccount = `-- name: ListArtifactsByAccount :many
SELECT id, account_id, header, header_version, data_encryption_key, seq, created_at, updated_at
FROM artifacts
WHERE account_id = ?
ORDER BY updated_at DESC
`

type ListArtifactsByAccountRow struct {
	ID                string    `json:"id"`
	AccountID         string    `json:"account_id"`
	Header            []byte    `json:"header"`
	HeaderVersion     int64     `json:"header_version"`
	DataEncryptionKey []byte    `json:"data_encryption_key"`
	Seq               int64     `json:"seq"`
	CreatedAt         time.Time `json:"created_at"`
	UpdatedAt         time.Time `json:"updated_at"`
}

func (q *Queries) ListArtifactsByAccount(ctx context.Context, accountID string) ([]ListArtifactsByAccountRow, error) {
	rows, err := q.db.QueryContext(ctx, listArtifactsByAccount, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListArtifactsByAccountRow{}
	for rows.Next() {
		var i ListArtifactsByAccountRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Header,
			&i.HeaderVersion,
			&i.DataEncryptionKey,
			&i.Seq,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateArtifact = `-- name: UpdateArtifact :execrows
UPDATE artifacts
SET
    header = COALESCE(?, header),
    header_version = CASE WHEN ? = 1 THEN ? ELSE header_version END,
    body = COALESCE(?, body),
    body_version = CASE WHEN ? = 1 THEN ? ELSE body_version END,
    seq = seq + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ? AND account_id = ?
  AND (? = 0 OR header_version = ?)
  AND (? = 0 OR body_version = ?)
`

type UpdateArtifactParams struct {
	Header          []byte      `json:"header"`
	Column2         interface{} `json:"column_2"`
	HeaderVersion   int64       `json:"header_version"`
	Body            []byte      `json:"body"`
	Column5         interface{} `json:"column_5"`
	BodyVersion     int64       `json:"body_version"`
	ID              string      `json:"id"`
	AccountID       string      `json:"account_id"`
	Column9         interface{} `json:"column_9"`
	HeaderVersion_2 int64       `json:"header_version_2"`
	Column11        interface{} `json:"column_11"`
	BodyVersion_2   int64       `json:"body_version_2"`
}

func (q *Queries) UpdateArtifact(ctx context.Context, arg UpdateArtifactParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateArtifact,
		arg.Header,
		arg.Column2,
		arg.HeaderVersion,
		arg.Body,
		arg.Column5,
		arg.BodyVersion,
		arg.ID,
		arg.AccountID,
		arg.Column9,
		arg.HeaderVersion_2,
		arg.Column11,
		arg.BodyVersion_2,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sessions.sql

package models

import (
	"context"
	"database/sql"
	"time"
)

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (
    id, tag, account_id, terminal_id, metadata, metadata_version,
    agent_state, agent_state_version, data_encryption_key
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, tag, account_id, terminal_id, metadata, metadata_version, agent_state, agent_state_version, data_encryption_key, seq, active, last_active_at, created_at, updated_at
`

type CreateSessionParams struct {
	ID                string         `json:"id"`
	Tag               string         `json:"tag"`
	AccountID         string         `json:"account_id"`
	TerminalID        string         `json:"terminal_id"`
	Metadata          string         `json:"metadata"`
	MetadataVersion   int64          `json:"metadata_version"`
	AgentState        sql.NullString `json:"agent_state"`
	AgentStateVersion int64          `json:"agent_state_version"`
	DataEncryptionKey []byte         `json:"data_encryption_key"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, createSession,
		arg.ID,
		arg.Tag,
		arg.AccountID,
		arg.TerminalID,
		arg.Metadata,
		arg.MetadataVersion,
		arg.AgentState,
		arg.AgentStateVersion,
		arg.DataEncryptionKey,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Tag,
		&i.AccountID,
		&i.TerminalID,
		&i.Metadata,
		&i.MetadataVersion,
		&i.AgentState,
		&i.AgentStateVersion,
		&i.DataEncryptionKey,
		&i.Seq,
		&i.Active,
		&i.LastActiveAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE id = ?
`

func (q *Queries) DeleteSession(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteSession, id)
	return err
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT id, tag, account_id, terminal_id, metadata, metadata_version, agent_state, agent_state_version, data_encryption_key, seq, active, last_active_at, created_at, updated_at FROM sessions WHERE id = ? LIMIT 1
`

func (q *Queries) GetSessionByID(ctx context.Context, id string) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSessionByID, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Tag,
		&i.AccountID,
		&i.TerminalID,
		&i.Metadata,
		&i.MetadataVersion,
		&i.AgentState,
		&i.AgentStateVersion,
		&i.DataEncryptionKey,
		&i.Seq,
		&i.Active,
		&i.LastActiveAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSessionByTag = `-- name: GetSessionByTag :one
SELECT id, tag, account_id, terminal_id, metadata, metadata_version, agent_state, agent_state_version, data_encryption_key, seq, active, last_active_at, created_at, updated_at FROM sessions
WHERE account_id = ? AND tag = ?
LIMIT 1
`

type GetSessionByTagParams struct {
	AccountID string `json:"account_id"`
	Tag       string `json:"tag"`
}

func (q *Queries) GetSessionByTag(ctx context.Context, arg GetSessionByTagParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSessionByTag, arg.AccountID, arg.Tag)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Tag,
		&i.AccountID,
		&i.TerminalID,
		&i.Metadata,
		&i.MetadataVersion,
		&i.AgentState,
		&i.AgentStateVersion,
		&i.DataEncryptionKey,
		&i.Seq,
		&i.Active,
		&i.LastActiveAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSessionLastMessage = `-- name: GetSessionLastMessage :one
SELECT id, session_id, local_id, seq, content, created_at, updated_at FROM session_messages
WHERE session_id = ?
ORDER BY seq DESC
LIMIT 1
`

func (q *Queries) GetSessionLastMessage(ctx context.Context, sessionID string) (SessionMessage, error) {
	row := q.db.QueryRowContext(ctx, getSessionLastMessage, sessionID)
	var i SessionMessage
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.LocalID,
		&i.Seq,
		&i.Content,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSessionMessagesCount = `-- name: GetSessionMessagesCount :one
SELECT COUNT(*) FROM session_messages WHERE session_id = ?
`

func (q *Queries) GetSessionMessagesCount(ctx context.Context, sessionID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getSessionMessagesCount, sessionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listActiveSessions = `-- name: ListActiveSessions :many
SELECT id, tag, account_id, terminal_id, metadata, metadata_version, agent_state, agent_state_version, data_encryption_key, seq, active, last_active_at, created_at, updated_at FROM sessions
WHERE account_id = ?
  AND active = 1
  AND last_active_at > datetime('now', '-15 minutes')
ORDER BY updated_at DESC
LIMIT ?
`

type ListActiveSessionsParams struct {
	AccountID string `json:"account_id"`
	Limit     int64  `json:"limit"`
}

func (q *Queries) ListActiveSessions(ctx context.Context, arg ListActiveSessionsParams) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, listActiveSessions, arg.AccountID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.Tag,
			&i.AccountID,
			&i.TerminalID,
			&i.Metadata,
			&i.MetadataVersion,
			&i.AgentState,
			&i.AgentStateVersion,
			&i.DataEncryptionKey,
			&i.Seq,
			&i.Active,
			&i.LastActiveAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessions = `-- name: ListSessions :many
SELECT id, tag, account_id, terminal_id, metadata, metadata_version, agent_state, agent_state_version, data_encryption_key, seq, active, last_active_at, created_at, updated_at FROM sessions
WHERE account_id = ?
ORDER BY updated_at DESC
LIMIT ?
`

type ListSessionsParams struct {
	AccountID string `json:"account_id"`
	Limit     int64  `json:"limit"`
}

func (q *Queries) ListSessions(ctx context.Context, arg ListSessionsParams) ([]Session, error) {
	rows, err := q.db.QueryContext(ctx, listSessions, arg.AccountID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.Tag,
			&i.AccountID,
			&i.TerminalID,
			&i.Metadata,
			&i.MetadataVersion,
			&i.AgentState,
			&i.AgentStateVersion,
			&i.DataEncryptionKey,
			&i.Seq,
			&i.Active,
			&i.LastActiveAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSessionActivity = `-- name: UpdateSessionActivity :exec
UPDATE sessions
SET active = ?, last_active_at = ?
WHERE id = ?
`

type UpdateSessionActivityParams struct {
	Active       int64     `json:"active"`
	LastActiveAt time.Time `json:"last_active_at"`
	ID           string    `json:"id"`
}

func (q *Queries) UpdateSessionActivity(ctx context.Context, arg UpdateSessionActivityParams) error {
	_, err := q.db.ExecContext(ctx, updateSessionActivity, arg.Active, arg.LastActiveAt, arg.ID)
	return err
}

const updateSessionAgentState = `-- name: UpdateSessionAgentState :execrows
UPDATE sessions
SET agent_state = ?, agent_state_version = ?
WHERE id = ? AND agent_state_version = ?
`

type UpdateSessionAgentStateParams struct {
	AgentState          sql.NullString `json:"agent_state"`
	AgentStateVersion   int64          `json:"agent_state_version"`
	ID                  string         `json:"id"`
	AgentStateVersion_2 int64          `json:"agent_state_version_2"`
}

func (q *Queries) UpdateSessionAgentState(ctx context.Context, arg UpdateSessionAgentStateParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateSessionAgentState,
		arg.AgentState,
		arg.AgentStateVersion,
		arg.ID,
		arg.AgentStateVersion_2,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateSessionMetadata = `-- name: UpdateSessionMetadata :execrows
UPDATE sessions
SET metadata = ?, metadata_version = ?
WHERE id = ? AND metadata_version = ?
`

type UpdateSessionMetadataParams struct {
	Metadata          string `json:"metadata"`
	MetadataVersion   int64  `json:"metadata_version"`
	ID                string `json:"id"`
	MetadataVersion_2 int64  `json:"metadata_version_2"`
}

func (q *Queries) UpdateSessionMetadata(ctx context.Context, arg UpdateSessionMetadataParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateSessionMetadata,
		arg.Metadata,
		arg.MetadataVersion,
		arg.ID,
		arg.MetadataVersion_2,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateSessionSeq = `-- name: UpdateSessionSeq :one
UPDATE sessions
SET seq = seq + 1
WHERE id = ?
RETURNING seq
`

func (q *Queries) UpdateSessionSeq(ctx context.Context, id string) (int64, error) {
	row := q.db.QueryRowContext(ctx, updateSessionSeq, id)
	var seq int64
	err := row.Scan(&seq)
	return seq, err
}
